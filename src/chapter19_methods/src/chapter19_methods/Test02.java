package chapter19_methods;
/*
 * ** Test01.java와 코드는 동일!
 * 
 *  < 메소드 사용 순서 >
 *  1. 메소드 정의 (기계 디자인하기)
 *  2. 메소드 호출 (기계 사용하기) 
 * 
 * 1. 메소드 정의 
 *  형식 : 
 *   ①리턴자료형 ②메소드명 (③매개변수 선언, 매개변수 선언, ...){
 *   	// 수행할 코드
 *   	④return ⑤리턴값; 
 *   }
 *   
 *  ① 리턴자료형(=반환자료형, 결과자료형)
 *    - 리턴값(결과 값)의 자료형
 *    - 기계를 돌려서 최종적으로 나온 결과(리턴값)의 '자료형'을 미리 명시하는 부분
 *    - 리턴값이 나오지 않는 메소드의 경우 void를 쓴다. 
 *       ** void : (직역:빈 공간) 자료형이 없다는 의미
 *  
 *  ② 메소드명 : 기계 이름
 *    - 기능을 대표하는 이름으로 지을 것
 *    - 맨 앞을 소문자로 할 것
 *      e.g. myMethod, showAllInfo, countNum, ...   
 *  
 *  ③ 매개변수
 *   - 매개변수란? 재료(인자값)이 들어올 수 있는 통로 역할의 변수    
 *   - 기계는 같은 소속의 멤버 변수 외의 값을 알 수 없음
 *   - 메소드에 필요한 재료만큼 매개변수를 선언해야 한다. 
 *   - 매개변수가 필요없는 메소드는 ()만 쓴다.
 *   
 *  ④ return
 *   - 종료하라 : 소속된 메소드를 종료해라. 
 *   - 반환하라 : 반환값이 있다면, 그 값을 호출된 자리에 갖다놔라. 
 *   - 돌아가라 : 메소드가 호출(사용)된 자리로 돌아가 남은 명령들을 진행하라.
 *      => return은 이 3가지 명령을 모두 수행한다. 
 *   - 리턴값이 없는 메소드일 경우 return 명령은 생략가능하다.
 *     (자동으로 '}' 바로 앞에 추가됨.)
 *  
 *  ⑤ 리턴값(=반환값, 결과값)
 *   - 메소드가 최종으로 만들어내는 결과물 
 *   - 이 값은 메소드가 사용된 곳으로 반환된다.
 *   - 주의! 
 *     1) 메소드 실행 1번 당 1개의 값만 반환 받을 수 있다.
 *        e.g. return a, b; (X)
 *        e.g. return a;
 *        	   return b; (X)
 *        단, if문과 switch문 등에 의해 반환값을 달리 줄 수는 있다. 
 *        e.g. if(..) {
 *        		 return 'A';
 *             } 
 *             else if(..) {
 *               return 'B';
 *             } 
 *             else {
 *             	 return 'C';
 *             }
 *     2) 반환자료형과 다른 값은 반환할 수 없다.
 *        e.g. 
 *        	int test(){
 *        		return 0; (O)
 *          }   
 *          
 *          int test(){
 *          	return "ABC"; (X)
 *          }
 *  ** 메소드 정의 시 주의사항
 *   (1) 클래스 내부에 작성하되, 메소드 안에 메소드를 정의할 수 없다.
 *   	=> 메인메소드 안에 정의할 수 없다!
 *   (2) 리턴 자료형은 맨 마지막에 결정하는 것이 만들기 편하다. 
 *       (코드를 쭉 작성하다가 리턴값이 결정되면 그때 쓰면 된다.)
 *   (3) 매개변수 vs 인자값은 자료형과 개수가 모두 일치해야 한다. 
 *       (통로    vs  재료) 
 *       e.g. 통로가 두 개일때 인자값 또한 2개 이상이 들어갈 수 없다.
 *            부족해도 안된다. 딱 2 개를 넣어야!!
 *   (4) 만들었다고 해서 바로 실행되는 것은 아니다! 
 *       메소드는 '호출'될 때 실행된다.
 * 
 * 2. 메소드 호출
 *  - 메소드 실행
 *    형식 : 메소드명(넣고 싶은 값);
 *  - 메소드가 호출되면, '()' 안에 있는 값을 재료로 넣고 해당 메소드를 실행한다.
 *    그리고 코드가 있던 자리에 리턴값이 돌아온다. (리턴값이 없다면 돌아오는 값은 없다.) 
 *    따라서 리턴값이 있는 메소드는, 
 *    보통 단독문장으로 사용되지 않고 : test(); (X)
 *    리턴값을 변수에 저장하거나,   : int n = test(); 
 *    출력해서 값을 확인하기도 한다   : System.out.println(test());  
 */
class Person2 {
	String name;
	int age;
	String tel;

	// void : 리턴값은 없다(결과물은 없다. 과정 자체가 목적인 메소드이다.)
	void setData(String n, int a, String t) { // 재료로는 String, int, String이 필요하다.
		name = n; // 첫 번째 재료를 (이 메소드를 소유한 객체의) name 필드에 저장하겠다.
		age = a;  // 두 번째 재료를 (이 메소드를 소유한 객체의) age 필드에 저장하겠다.
		tel = t;  // 세 번째 재료를 (이 메소드를 소유한 객체의) tel 필드에 저장하겠다.
//		return; // 생략가능
	}
	
	// void : 리턴값은 없다(결과물은 없다. 과정 자체가 목적인 메소드이다.)
	void printInfo() { // 재료 또한 필요 없다.
		System.out.println(name + ", " + age + "세, tel." + tel); // (이 메소드를 소유한 객체의) 필드를 모두 출력하겠다.
//		return; // 생략가능
	}
	
	// String : 이 메소드는 String(문자열)을 결과물로 내는 메소드이다.
	String getData() { // 재료는 필요 없다.
		return "이름 : " + name + "\n나이 : " + age + "\n연락처 : " + tel;
//		       ------------------------------------------------------ 리턴값 (String)
	}
}


public class Test02 {
	public static void main(String[] args) {
		// 주의! 위에서 만든 메소드 또한 설계도이기 때문에,
		//      객체 생성을 해야 기계가 만들어진다. 
		Person2 p1 = new Person2(); 
		Person2 p2 = new Person2();
		// 위의 두 인스턴스는 개인 소유의 기계를 소유하고 있다. (정확하게는 틀린 말이지만.. 이렇게 생각해도 괜찮다.)
		
		
		p1.setData("김피카츄", 10, "010-1111-2222"); 
		p2.setData("이푸린", 5, "없음");
		
		p1.printInfo(); // 김피카츄, 10세, tel.010-1111-2222
		p2.printInfo(); // 이푸린, 5세, tel.없음
		System.out.println();
		
		String data = p1.getData(); 
		System.out.println(data); 
//		이름 : 김피카츄
//		나이 : 10
//		연락처 : 010-1111-2222
		
		System.out.println(p2.getData());
//		이름 : 이푸린
//		나이 : 5
//		연락처 : 없음

	}
}








