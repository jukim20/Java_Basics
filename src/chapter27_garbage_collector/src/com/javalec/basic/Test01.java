package com.javalec.basic;
/* 
 * < 자바가 사용하는 RAM 메모리의 구조 >
 * 1. STACK 영역
 *  - 정적할당 영역 
 *  - 지역변수, 매개변수의 할당 영역
 * 2. HEAP 영역
 *  - 동적할당 영역
 *  - 인스턴스, 배열의 할당 영역
 *  - 주소로만 접근한다. 
 * 3. METHOD 영역(CLASS 영역, STATIC 영역)
 *  - static 멤버의 할당 영역
 *  - 클래스 로드 영역 (.class 파일의 내용물인 바이트 코드가 로드되는 영역)
 *  
 * < 정적할당과 동적할당 >
 * 1. 정적할당 
 *  - 컴파일 시 결정되는 할당(=개발자가 미리 계획하는 할당)
 *    int형 변수 만들어라... 3칸짜리 배열 만들어라 등등
 *  - 생명 주기가 결정되어있음.(선언될 때 태어나고, 그 변수가 속한 영역이 끝나면 사라짐.)
 *  - 성질이 변하지 않음 (int형 변수가 double형으로 변한다거나..)
 *  - 단점 : 
 *      더이상 필요없는 메모리가 자리만 차지할 때도 있고,
 *      재할당(성질 바꾸기)이 안됨
 *      따라서 메모리가 비효율적으로 사용될 수 있음
 *  
 * 2. 동적할당
 *  - 프로그램 실행 중 결정되는 할당 
 *    e.g. 학생 수 입력 받고 -> 입력 받은 수 만큼 이름을 저장할 배열을 생성하라 
 *         (3 입력하면 3칸, 10 입력하면 10칸 => 프로그램 실행 중 몇 명을 입력하느냐에 따라서 배열 크기가 달라짐.)
 *  - 개발자가 작성한 '할당해라!'는 명령이 실행될 때 생성, '해제하라!'는 명령이 실행될 때 해제. 
 *    해제명령이 없으면 프로그램이 종료될 때 해제. 
 *      => 정적할당은 생명주기가 정해져있고 
 *         동적할당은 정해져있지 않음
 *  - 단점 : 서버와 같이 프로그램을 종료하면 안되는 프로그램에 해제 명령을 빼먹으면 어느새 메모리가 가득참 
 *     => 자바에서는 이러한 상황을 막기위한 '가비지 컬렉터'가 있음.
 *         - 자바에서는 new 연산자가 실행될 때 생성되고,
 *    		  해제는 자동으로 가비지 컬렉터가 해줌. (해제명령이 따로 없음)
 * 
 */

class Person {
	String name;
	int age;
}
public class Test01 {
	public static void main(String[] args) {
		// < 가비지 컬렉터(Garbage Collector) >
		//   - 객체나 배열을 자동으로 해제
		
		// 객체의 레퍼런스를 잃어버린 경우, 접근할 수 없는 객체로 판단하여 자동으로 해제한다. 
		System.out.println(new Person()); //com.javalec.basic.Person@70dea4e
		// 실제 객체는 만들어지지만 출력 이후로는 이 객체에 접근할 수 있는 방법이 없음 (이때 가비지 컬렉터가 출동하여 위 객체를 해제)
		
		Person p;
		p = new Person();
		System.out.println(p); //com.javalec.basic.Person@5c647e05
		
		p = new Person();
		System.out.println(p); //com.javalec.basic.Person@33909752
		// p에는 33909752번 객체가 담겨있음. 따라서 이전에 적혀있던 5c647e05는 없어짐
		// 5c647e05에 대한 객체는 더이상 접근할 수 없으므로 이때 가비지 컬렉터가 출동
		
		
	}
}





















